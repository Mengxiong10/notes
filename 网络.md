## 有了 mac 地址, 为什么还要 ip 地址

如果没有 IP 地址, 那么路由器要记住所有的 mac 地址来转发, 内存是不太可能的, ip 地址设计的目的是把网络分成很多子网, 这样路由器把子网可以整体计算只需要让数据包到达那个子网就行了.

mac 地址就像身份证号, IP 地址就像带着邮政编码的住址.

## web 页面请求历程

1. 主机接入网络获取本地 IP 地址以及其他信息

   使用 DHCP 发现报文完成.

   运输层 UDP 目的地端口地址 67(DHCP 服务器)和源端口地址 68(DHCP 客户)

   网络层目的地 IP 地址(255.255.255.255)进行广播和源 IP 地址(0.0.0.0)

   链路层目的 MAC 地址 FF:FF:FF:FF:FF:FF 广播, 源 MAC 地址就是设备的 MAC 地址

   DHCP 服务器收到后分配一个 IP 地址, 然后将这个 IP 地址, 路由器 IP 地址, DNS 服务器的 IP 地址, 子网掩码信息返回, 目的 MAC 地址就是主机的 mac 地址, 然后路由记住了之前发送过来 mac 地址的端口, 向那个端口的主机发送这个回复, 主机就收到了 IP 地址和 DNS 服务器地址

2. ARP(地址解析协议, 将 IP 地址转化为 MAC 地址)

   有了网关路由器的 IP 地址, 然后通过 ARP 协议获取网关路由器的 MAC 地址

3. DNS 查询

   请求主机->本地 DNS 服务器->根 DNS 服务器->顶级域名服务器->权威域名服务器

   这个过程任何 DNS 查询既可以是递归也可以是迭代的.

   迭代就是问完后别人直接返回让你继续问下一个, 递归就是问完后, 别人帮你问下一个, 最后再返回.

   这个过程中还有缓存, 浏览器会缓存, 操作系统 host 也是缓存, 本地 DNS 服务器也会缓存

   DNS 应答报文, 包含一个或多个资源记录, 资源记录是(Name, Value, Type, TTL)的 4 元祖

   Type 是 A | NS | CNAME | MX

   A 的时候 Value 就是 IP 地址

   CNAME 的时候就 Value 就是这个别名 Name 的规范主机名

   NS 的时候是查询链的时候, Value 就是让你问的下一个 DNS 的主机名

   MX: Value 是别名为 Name 的邮件服务器的规范主机名

   TTL 记录缓存的时长

4. TCP 连接

   三次握手以建立 TCP 连接
   第一次握手：建立连接时，客户端发送 syn 包（syn=1， Seq=x）到服务器，并进入 SYN_SENT 状态，等待服务器确认；
   第二次握手：服务器收到 syn 包，自己也发送一个 SYN 包（syn=1,ack=x+1,seq=y），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；
   第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=k+1），此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP 连接成功）状态，完成三次握手。
   补充：
   为什需要三次握手？
   ​ 《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”，书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。”。主要目的防止 server 端一直等待，浪费资源。

5. TLS连接

#### TCP慢启动/14kb规则

为了均衡网络连接速度， 第一个响应包是14kb大小，然后逐渐加倍到预定的阈值或遇到拥塞

### HTTPS

SSL/TLS 协议, TLS 是 SSL 后续协议名称.

需要经过 4 次握手 (前面还有 TCP 的 3 次握手, 一共 7 次)

1. 客户端发出请求 (报告自己支持的 SSL/TLS 协议版本, 加密套件列别, 算法列表等的)

2. 服务端回应(自己的证书, 协议版本等等)

   证书包含 服务器公钥, 服务器信息, 然后对这个信息使用 Hash 算法得到消息摘要然后用 CA 私钥加密这个消息摘要得到数字签名

3. 客户端验证证书

   同样的 Hash 算法得到消息摘要, 然后用浏览器预设的 CA 公钥解密数字签名得到摘要对比, 这样就确定这个公钥是服务器的. 然后用这个公钥对一个随机数加密 (用于生成之后通信的对称密钥)

4. 服务器回应 (用私钥解密随机数 获取对称密钥)

### HTTP/2

为什么不是 HTTP/1.2, HTTP/2 引入了一个二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输, HTTP 语义不受影响但是传输方式变了, 并不能和 HTTP/1.x 兼容.(编码方式变了, HTTP/1.x 协议以换行符作为纯文本的分隔符，而 HTTP/2 将所有传输的信息分割为更小的消息和帧，并采用二进制格式对它们编码)

1. 请求与响应复用

   在 HTTP/1.x 中, HTTP 虽然可以通过 keep-alive 复用 TCP 连接, 但是一个 TCP 连接上的 HTTP 请求只能是串行请求的, 客户端只能通过多个 TCP 连接发起并行请求提升性能, 但是浏览器限制了同一个域同时最多只能发起 6 个 TCP 请求, 这样出现了域分片的优化手段, 就是通过不同域名子域去请求资源, 但是额外 DNS 查询和 TCP 慢启动还是会损害一些性能.

   在 HTTP/2 中客户端向一个域名请求过程, 只会创建一条 TCP 连接, 通过多路复用 ,分解 HTTP 消息, 然后重新组装 HTTP 请求都通过一个连接并行的请求和响应. 基于此, 原来针对 HTTP/1.x 合并请求资源减少 HTTP 请求的优化没必要了, 反而会影响缓存.

2. 数据流优先级

   将 HTTP 消息分解为独立的帧后, HTTP/2 标准允许为每个数据流设置权重, 这样服务器可以将高优先级以最优方式传给客户端

3. 服务器推送

   服务器除了对最初的请求响应之外, 服务器还可以向客户端推送额外的资源, 无需客户端明确请求, 比如 html 请求, 服务器分析知道客户端接下来会请求里面的 js,css 等文件, 就可以一起返回给客户端, 这个功能帮助客户端将资源放进缓存以备将来之需, 当然客户端也可以通过发送 `RST_STREAM`帧拒绝.

4. 头部压缩

   在 HTTP/1.x 中, 头部数据是以纯文本形式,通常开销在 500-800 字节, 而且大多的 HTTP 头部数据都是相同的, 为了减少开销, HTTP/2 搞了个 HPACK 压缩头部元数据, 就是把报文中字段名和值变成索引值, 这样就有 了索引表, 常用的 HTTP 标头放在静态表, 静态表由规范定义, 例如`method: GET`对应成索引表中 index 为 2 的一个值, 然后头部不确定的如 user-agent 等维护在一个动态索引表, 动态的添加.

### 安全

### 性能优化

### Webpack

### Babel

### React

### Typescript
